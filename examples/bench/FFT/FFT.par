// change int to double in implementation
type complex = int * int;

poly L = K () + K complex * I;
poly T = K (() + complex) + I * I;

atom fl  : Rec L * Rec L -> Rec L;
atom fr  : Rec L * Rec L -> Rec L;
atom fo  : Rec L -> Rec L;
atom deinterleave : Rec L -> T (Rec L);
atom app : Rec L * Rec L -> Rec L;


fun nil : () -> Rec L
  = in . inj[0,2];

fun cons : complex * Rec L -> Rec L
  = in . inj[1,2];

fun singleton : complex -> Rec L
  = cons . (id &&& (nil . const ()));

fun fft : Rec L -> Rec L
  = rec[T] (((nil ||| singleton) ||| app) . (id +++ (fl &&& fr)) . (id +++ (id *** fo))) deinterleave;

par fftp1 = fft {
  unroll 2;
  annotate {
    fft
  }
};

// par fftp2 = fft {
//   unroll 2;
//   annotate {
//     fl;
//     fr
//   }
// };
//
// par fftp3 = fft {
//   unroll 3;
//   annotate {
//     fl;
//     fr
//   }
// };
//
// par fftp4 = fft {
//   unroll 4;
//   annotate {
//     fl;
//     fr
//   }
// };
//
// par fftp5 = fft {
//   unroll 5;
//   annotate {
//     fl;
//     fr
//   }
// };
