poly L1 = K () + K (int * int) * I;
poly L2 = K () + K int * I;
poly T = I * I;

atom times : int * int -> int;
atom plus : int * int -> int;

fun dot0 : Rec L1 -> int
  = rec [L1] ((const 0 ||| plus) . (id +++ times *** id)) out;

atom split : Rec L1 -> T (Rec L1);

//fun dot1 : Rec L1 -> int
//   = plus . [T] dot0 . split;
//
//fun dot2 : Rec L1 -> int
//   = plus . [T] (plus . [T] dot0 . split) . split;
//
fun dot3 : Rec L1 -> int
   = plus . [T] (plus . [T] (plus . [T] dot0 . split) . split) . split;
//
//fun dot4 : Rec L1 -> int
//   = plus . [T] (plus . [T] (plus . [T] (plus . [T] dot0 . split) . split) . split) . split;
//
//fun dot5 : Rec L1 -> int
//   = plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] dot0 . split) . split) . split) . split) . split;
//
//fun dot6 : Rec L1 -> int
//   = plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] dot0 . split) . split) . split) . split) . split) . split;
//
//fun dot7 : Rec L1 -> int
//   = plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] dot0 . split). split) . split) . split) . split) . split) . split;
//
//fun dot8 : Rec L1 -> int
//   = plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] (plus . [T] dot0 . split). split). split) . split) . split) . split) . split) . split;

//par dot1 { annotate { dot0 } };
//par dot2 { annotate { dot0 } };
par dot3 { annotate { dot0 } };
//par dot4 { annotate { dot0 } };
//par dot5 { annotate { dot0 } };
//par dot6 { annotate { dot0 } };
//par dot7 { annotate { dot0 } };
//par dot8 { annotate { dot0 } };

//atom merge : T Rec L -> Rec L;
//
//fun ms : Rec L -> Rec L
//  = rec [T] merge split;
//
//par ms {
//  unroll 6;
//  annotate
//    {
//    merge
//    ;
//    rec [T] merge split
//    }
//};
